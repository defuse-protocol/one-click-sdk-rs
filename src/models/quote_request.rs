/*
 * 1Click Swap API
 *
 * API for One-Click Swaps
 *
 * The version of the OpenAPI document: 0.1
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct QuoteRequest {
    /// Flag indicating whether this is a dry run request. If `true`, the response will **NOT** contain the following fields: - `depositAddress` - `timeWhenInactive` - `timeEstimate` - `deadline`
    #[serde(rename = "dry")]
    pub dry: bool,
    /// Whether to use the amount as the output or the input for the basis of the swap: - `EXACT_INPUT` - request output amount for exact input. - `EXACT_OUTPUT` - request output amount for exact output. The `refundTo` address will always receive excess tokens back even after the swap is complete.
    #[serde(rename = "swapType")]
    pub swap_type: SwapType,
    /// Slippage tolerance for the swap. This value is in basis points (1/100th of a percent), e.g. 100 for 1% slippage.
    #[serde(rename = "slippageTolerance")]
    pub slippage_tolerance: f64,
    /// ID of the origin asset.
    #[serde(rename = "originAsset")]
    pub origin_asset: String,
    /// Type of the deposit address: - `ORIGIN_CHAIN` - deposit address on the origin chain - `INTENTS` - **account ID** inside near intents to which you should transfer assets inside intents.
    #[serde(rename = "depositType")]
    pub deposit_type: DepositType,
    /// ID of the destination asset.
    #[serde(rename = "destinationAsset")]
    pub destination_asset: String,
    /// Amount to swap as the base amount (can be switched to exact input/output using the dedicated flag), denoted in the smallest unit of the specified currency (e.g., wei for ETH).
    #[serde(rename = "amount")]
    pub amount: String,
    /// Address for user refund.
    #[serde(rename = "refundTo")]
    pub refund_to: String,
    /// Type of refund address: - `ORIGIN_CHAIN` - assets will be refunded to `refundTo` address on the origin chain - `INTENTS` - assets will be refunded to `refundTo` intents account
    #[serde(rename = "refundType")]
    pub refund_type: RefundType,
    /// Recipient address. The format should match `recipientType`.
    #[serde(rename = "recipient")]
    pub recipient: String,
    /// Type of recipient address: - `DESTINATION_CHAIN` - assets will be transferred to chain of `destinationAsset` - `INTENTS` - assets will be transferred to account inside intents
    #[serde(rename = "recipientType")]
    pub recipient_type: RecipientType,
    /// Timestamp in ISO format, that identifies when user refund will begin if the swap isn't completed by then.
    #[serde(rename = "deadline")]
    pub deadline: String,
    /// Referral identifier
    #[serde(rename = "referral", skip_serializing_if = "Option::is_none")]
    pub referral: Option<String>,
    /// Time in milliseconds user is willing to wait for quote from relay.
    #[serde(rename = "quoteWaitingTimeMs", skip_serializing_if = "Option::is_none")]
    pub quote_waiting_time_ms: Option<f64>,
}

impl QuoteRequest {
    pub fn new(dry: bool, swap_type: SwapType, slippage_tolerance: f64, origin_asset: String, deposit_type: DepositType, destination_asset: String, amount: String, refund_to: String, refund_type: RefundType, recipient: String, recipient_type: RecipientType, deadline: String) -> QuoteRequest {
        QuoteRequest {
            dry,
            swap_type,
            slippage_tolerance,
            origin_asset,
            deposit_type,
            destination_asset,
            amount,
            refund_to,
            refund_type,
            recipient,
            recipient_type,
            deadline,
            referral: None,
            quote_waiting_time_ms: None,
        }
    }
}
/// Whether to use the amount as the output or the input for the basis of the swap: - `EXACT_INPUT` - request output amount for exact input. - `EXACT_OUTPUT` - request output amount for exact output. The `refundTo` address will always receive excess tokens back even after the swap is complete.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum SwapType {
    #[serde(rename = "EXACT_INPUT")]
    ExactInput,
    #[serde(rename = "EXACT_OUTPUT")]
    ExactOutput,
}

impl Default for SwapType {
    fn default() -> SwapType {
        Self::ExactInput
    }
}
/// Type of the deposit address: - `ORIGIN_CHAIN` - deposit address on the origin chain - `INTENTS` - **account ID** inside near intents to which you should transfer assets inside intents.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum DepositType {
    #[serde(rename = "ORIGIN_CHAIN")]
    OriginChain,
    #[serde(rename = "INTENTS")]
    Intents,
}

impl Default for DepositType {
    fn default() -> DepositType {
        Self::OriginChain
    }
}
/// Type of refund address: - `ORIGIN_CHAIN` - assets will be refunded to `refundTo` address on the origin chain - `INTENTS` - assets will be refunded to `refundTo` intents account
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum RefundType {
    #[serde(rename = "ORIGIN_CHAIN")]
    OriginChain,
    #[serde(rename = "INTENTS")]
    Intents,
}

impl Default for RefundType {
    fn default() -> RefundType {
        Self::OriginChain
    }
}
/// Type of recipient address: - `DESTINATION_CHAIN` - assets will be transferred to chain of `destinationAsset` - `INTENTS` - assets will be transferred to account inside intents
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum RecipientType {
    #[serde(rename = "DESTINATION_CHAIN")]
    DestinationChain,
    #[serde(rename = "INTENTS")]
    Intents,
}

impl Default for RecipientType {
    fn default() -> RecipientType {
        Self::DestinationChain
    }
}

