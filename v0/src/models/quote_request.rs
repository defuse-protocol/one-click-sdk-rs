/*
 * 1Click Swap API
 *
 * API for One-Click Swaps
 *
 * The version of the OpenAPI document: 0.1.8
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct QuoteRequest {
    /// Flag indicating whether this is a dry run request. If `true`, the response will **NOT** contain the following fields: - `depositAddress` - `timeWhenInactive` - `deadline`
    #[serde(rename = "dry")]
    pub dry: bool,
    /// Whether to use the amount as the output or the input for the basis of the swap: - `EXACT_INPUT` - request output amount for exact input. - `EXACT_OUTPUT` - request output amount for exact output. The `refundTo` address will always receive excess tokens back even after the swap is complete. - `FLEX_INPUT` - flexible input amount that allows for partial deposits and variable amounts.
    #[serde(rename = "swapType")]
    pub swap_type: SwapType,
    /// Slippage tolerance for the swap. This value is in basis points (1/100th of a percent), e.g. 100 for 1% slippage.
    #[serde(rename = "slippageTolerance")]
    pub slippage_tolerance: f64,
    /// ID of the origin asset.
    #[serde(rename = "originAsset")]
    pub origin_asset: String,
    /// Type of the deposit address: - `ORIGIN_CHAIN` - deposit address on the origin chain - `INTENTS` - **account ID** inside near intents to which you should transfer assets inside intents.
    #[serde(rename = "depositType")]
    pub deposit_type: DepositType,
    /// ID of the destination asset.
    #[serde(rename = "destinationAsset")]
    pub destination_asset: String,
    /// Amount to swap as the base amount (can be switched to exact input/output using the dedicated flag), denoted in the smallest unit of the specified currency (e.g., wei for ETH).
    #[serde(rename = "amount")]
    pub amount: String,
    /// Address for user refund.
    #[serde(rename = "refundTo")]
    pub refund_to: String,
    /// Type of refund address: - `ORIGIN_CHAIN` - assets will be refunded to `refundTo` address on the origin chain - `INTENTS` - assets will be refunded to `refundTo` intents account
    #[serde(rename = "refundType")]
    pub refund_type: RefundType,
    /// Recipient address. The format should match `recipientType`.
    #[serde(rename = "recipient")]
    pub recipient: String,
    /// EVM address of a transfer recipient in a virtual chain
    #[serde(rename = "virtualChainRecipient", skip_serializing_if = "Option::is_none")]
    pub virtual_chain_recipient: Option<String>,
    /// EVM address of a refund recipient in a virtual chain
    #[serde(rename = "virtualChainRefundRecipient", skip_serializing_if = "Option::is_none")]
    pub virtual_chain_refund_recipient: Option<String>,
    /// Type of recipient address: - `DESTINATION_CHAIN` - assets will be transferred to chain of `destinationAsset` - `INTENTS` - assets will be transferred to account inside intents
    #[serde(rename = "recipientType")]
    pub recipient_type: RecipientType,
    /// Timestamp in ISO format, that identifies when user refund will begin if the swap isn't completed by then. It needs to exceed the time required for the deposit tx to be minted, e.g. for Bitcoin it might require ~1h depending on the gas fees paid.
    #[serde(rename = "deadline")]
    pub deadline: String,
    /// Referral identifier(lower case only). It will be reflected in the on-chain data and displayed on public analytics platforms.
    #[serde(rename = "referral", skip_serializing_if = "Option::is_none")]
    pub referral: Option<String>,
    /// Time in milliseconds user is willing to wait for quote from relay.
    #[serde(rename = "quoteWaitingTimeMs", skip_serializing_if = "Option::is_none")]
    pub quote_waiting_time_ms: Option<f64>,
    /// List of recipients and their fees
    #[serde(rename = "appFees", skip_serializing_if = "Option::is_none")]
    pub app_fees: Option<Vec<models::AppFee>>,
}

impl QuoteRequest {
    pub fn new(dry: bool, swap_type: SwapType, slippage_tolerance: f64, origin_asset: String, deposit_type: DepositType, destination_asset: String, amount: String, refund_to: String, refund_type: RefundType, recipient: String, recipient_type: RecipientType, deadline: String) -> QuoteRequest {
        QuoteRequest {
            dry,
            swap_type,
            slippage_tolerance,
            origin_asset,
            deposit_type,
            destination_asset,
            amount,
            refund_to,
            refund_type,
            recipient,
            virtual_chain_recipient: None,
            virtual_chain_refund_recipient: None,
            recipient_type,
            deadline,
            referral: None,
            quote_waiting_time_ms: None,
            app_fees: None,
        }
    }
}
/// Whether to use the amount as the output or the input for the basis of the swap: - `EXACT_INPUT` - request output amount for exact input. - `EXACT_OUTPUT` - request output amount for exact output. The `refundTo` address will always receive excess tokens back even after the swap is complete. - `FLEX_INPUT` - flexible input amount that allows for partial deposits and variable amounts.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum SwapType {
    #[serde(rename = "EXACT_INPUT")]
    ExactInput,
    #[serde(rename = "EXACT_OUTPUT")]
    ExactOutput,
    #[serde(rename = "FLEX_INPUT")]
    FlexInput,
}

impl Default for SwapType {
    fn default() -> SwapType {
        Self::ExactInput
    }
}
/// Type of the deposit address: - `ORIGIN_CHAIN` - deposit address on the origin chain - `INTENTS` - **account ID** inside near intents to which you should transfer assets inside intents.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum DepositType {
    #[serde(rename = "ORIGIN_CHAIN")]
    OriginChain,
    #[serde(rename = "INTENTS")]
    Intents,
}

impl Default for DepositType {
    fn default() -> DepositType {
        Self::OriginChain
    }
}
/// Type of refund address: - `ORIGIN_CHAIN` - assets will be refunded to `refundTo` address on the origin chain - `INTENTS` - assets will be refunded to `refundTo` intents account
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum RefundType {
    #[serde(rename = "ORIGIN_CHAIN")]
    OriginChain,
    #[serde(rename = "INTENTS")]
    Intents,
}

impl Default for RefundType {
    fn default() -> RefundType {
        Self::OriginChain
    }
}
/// Type of recipient address: - `DESTINATION_CHAIN` - assets will be transferred to chain of `destinationAsset` - `INTENTS` - assets will be transferred to account inside intents
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum RecipientType {
    #[serde(rename = "DESTINATION_CHAIN")]
    DestinationChain,
    #[serde(rename = "INTENTS")]
    Intents,
}

impl Default for RecipientType {
    fn default() -> RecipientType {
        Self::DestinationChain
    }
}

